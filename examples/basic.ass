// Example syntax for a basic assembly with a few instructions

%constant var 65535

//Memory parameters
%param opcode_width    16
%param memory_width    16
%param alignment       16
%param address_width   14
%param address_start   0
%param address_stop    var
%param endianness      "big"

//Syntax parameters
%param args_separator  ","
%param label_pattern   "[a-z][a-z0-9_]:"

// Constants for opcode prefix
%constant rr_p $00001
%constant cnt 154

// Register enumeration
%enum    reg 3
%pattern reg "pc" $0h
%pattern reg "sp" $1h
%pattern reg "r0" $2h
%pattern reg "r1" $3h
%pattern reg "r2" $4h
%pattern reg "r3" $5h
%pattern reg "r4" $6h
%pattern reg "r5" $7h

%enum    io 7
%pattern io "PORTA" $20h
%pattern io "PORTB" $24h
%pattern io "PORTC" $28h
%pattern io "TRISA" $30h
%pattern io "TRISB" $34h
%pattern io "TRISC" $38h


// Format for arithmetic instructions between registers
%format rr_f  [$rr_p, ..., ID(4), reg, reg] // 5bits + 4bits + 3bits + 3bits = 14bits -> filling is 1 bit wide
%order rr_f    4 3 // register1 register2

%opcode rr_f "add" $0h  /// @desc Add two registers and write the result to register 2
%opcode rr_f "sub" $1h  /// @desc Substract register2 from register 1 and write the result to register 2
%opcode rr_f "mul" $2h  /// @desc Multiply two registers and write the result to register 2
%opcode rr_f "div" $3h  /// @desc Divide register2 by register1 and write the result to register 2
%opcode rr_f "and" $4h  /// @desc Bitwise and on two registers  and write the result to register 2
%opcode rr_f "or"  $5h  /// @desc Bitwise or on two registers  and write the result to register 2
%opcode rr_f "xor" $6h  /// @desc Bitwise or on two registers  and write the result to register 2

//Format for conditionnal jumps
%format brch_f [$001, ID(2), LABEL_REL(8), reg] // All bits are used, can only jump 128 forward or 127 backward, 0 means go to next instruction
%order brch_f 3 2 // Reordering to have the register as first argument

%opcode brch_f "bz"  $0h  /// @desc Branch if register is equal to zero
%opcode brch_f "bnz" $1h  /// @desc Branch if register is not equal to zero
%opcode brch_f "bgz" $2h  /// @desc Branch if register is greater than zero
%opcode brch_f "bsz" $3h  /// @desc Branch if register is smaller than zero


//Jumps
%format jmp_f [$1, ..., LABEL_ABS(14)]
%opcode jmp_f "jmp"  /// @desc Jump to a label.

//Data movements
%format mv_f [$0001, ID(1), reg, LABEL_ABS(8)]
%order mv_f 3 2
%opcode mv_f "ld" $0h  /// @desc Load from memory in the first 256 adresses to a register
%opcode mv_f "str" $1h /// @desc Store from a register to memory in the first 256 adresses
